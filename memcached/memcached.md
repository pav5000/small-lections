# Memcached

Это просто большая мапка в памяти.
Данные хранятся только в пямяти, никакого сброса на диск.
В целом, это можно рассматривать как "ненадежное, но **очень** быстрое key-value хранилище"

## Запускаем

`sudo docker run --rm -ti --network host --name memcache memcached memcached -m 64 -vvv`

Рассмотрим команду запуска подробнее.
- `docker run` -- запустить докер-контейнер
- `--rm` -- удалить контейнер при завершении его работы, чтобы не засорять комп
- `-ti` -- показать нам консоль
- `--network host` -- отключить докеровский NAT, чтобы приложение имело доступ к сети напрямую
- `--name memcache` -- назовем наш контейнер memcache
- `memcached` -- имя образа, из которого мы создаем контейнер. Это стандартный образ Мемкэша из репы Докера.
- `memcached -m 64 -vvv` -- какую команду запустить внутри контейнера. Тут мы запускаем сам мемкэш, говорим ему использовать 65Мб памяти и включить verbose-режим (чтобы он писал о всех операциях в консоль).

Можем еще указать параметры:
- `-l 127.0.0.1` -- слушать только локалхост
- `-p 11211` -- слушать на определенном порту (11211 принят по-умолчанию)
- `-n 48` -- сколько байт синимально аллоцировать под одну запись. Уменьшение этого значения может уменьшить потребление памяти при куче мелких ключей.
- `-C` -- выключить Compare and swap (уменьшает размер записи на 8 байт).
- `-I 1m` -- размер одного блока в памяти. Одна запись не может быть больше, чем этот размер.

**Важно:** при старте мемкэш сразу занимает всю память, которую мы ему указали в параметре `-m`. Это сделано для оптимизации.

## Смотрим на протокол

Ключ — текстовая строка длиной до 250 байт. Запрещены контрольные символы и пробелы.

![Джейсон запрещает нам](images/jason.jpg)

Значение — любые бинарные данные.

# Обзор команд

Сохранение и изменение данных:
- `set` **99% времени используем только ее, тупо создает или заменяет запись**
- `add` сохраняет запись только если такого ключа еще нет
- `replace` сохраняет записть только если такой ключ уже есть
- `append` добавить данные в конец записи
- `prepend` добавить данные в начало записи
- `cas` сохраняет запись только если ее никто не менял со времени последнего чтения
- `delete` удаляет запись (можно выставить задержку удаления)
- `incr/decr` Прибавляет или убавляет число к записи. Работает только если данные в записи это int64 в строковой форме. Прибавить или отнять можно только положительное число. Операция атомарная.

Получение данных:
- `get` **99% времени используем только ее, тупо получаем одну или несколько записей**
- `gets` то же самое, что `get`, но мы получаем еще id для CAS
- `flush_all` убить вообще все данные. При выполнении память освобождается не мгновенно, просто все записи помечаются протухшими.

# Протухание записи

При создании записи есть возможность указать время, через которое эта запись удалится из кэша.
Время всегда задается просто целым числом, но в зависимости от диапазона, меняется смысл этого числа:
- Если указан 0, то запись никогда не протухнет.
- От 1 до 2592000, это количество секунд через которое запись протухает. Максимальное значение 30 дней.
- Выше 2592000, это считается как unixtime момента, когда запись протухает.

Запись так же может быть удалена **до** момента своего протухания, если кончилась память.
В случае нехватки памяти первыми из кэша удаляются те записи, над которыми дольше всего не выполнялись никакие операции. Это называется LRU-кэш, least recently used (Вытеснение давно неиспользуемых).

# Текстовый протокол

Это просто справочно-развлекательный раздел, ибо вручную мы с протоколом обычно не работаем.
Информация здесь для того, чтобы лучше представлять, как клиент в твоей программе работает с мемкешем.

Общий формат команды set: `set key [flags] [exptime] length [noreply]`
Например, попробуем положить запись.
```
$ telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
set testkey 0 60 6
abcdef
STORED
```
Разбор команды:
|                  |                |
| ---------------- |:-------------: |
| ключ             | testkey        |
| флаги            | 0 (без флагов) |
| время протухания | 60 секунд      |
| длина данных     | 6 байт         |
| данные           | abcdef         |

По этому примеру видно, почему в ключе нельзя использовать пробелы и контрольные символы.
При этом, в данных можно использовать любые байты, ибо мы указали их длину и сервер просто будет читать указанное количество байт.

Попробуем теперь получить запись, которую мы положили в кэш.
```
get testkey
VALUE testkey 0 6
abcdef
END
```

При `get` мы можем перечислить несколько ключей.
Формат ответа сервера: `VALUE key flags bytes`

Разбор ответа:
|                  |                |
| ---------------- |:-------------: |
| ключ             | testkey        |
| флаги            | 0 (без флагов) |
| длина данных     | 6 байт         |
| данные           | abcdef         |

## Работаем из golang

```golang
package main

import (
	"fmt"

    // Что интересно, автор этого пакета создал мемкэш
    // И он же является одним из основных разработчиков golang
	"github.com/bradfitz/gomemcache/memcache"
)

func main() {
	mc := memcache.New("127.0.0.1:11211") // Тут можем перечислить несколько серверов

	err := mc.Set(&memcache.Item{
		Key:        "testkey",
		Value:      []byte("some value"),
		Expiration: 20,
	})
	if err != nil {
		panic(err)
	}

	it, err := mc.Get("testkey")
	if err != nil {
		panic(err)
	}

	fmt.Println("Key:", string(it.Key))
	fmt.Println("Value:", string(it.Value))
}
```

## Шардирование

Мемкэш можно шардировать на несколько серверов.
Делается это силами **клиента**, сами сервера ничего не знают друг о друге и о том, что они вообще шардированы.
Сделано так для того, чтобы максимально упростить использование мемкэша.
Чтобы использовать эту фичу, нам при вызове `memcache.New(...)` нужно указать несколько серверов.

# Как распределяются записи по серверам

Используется согласованное хеширование (consistent hashing).
Это вид хеширования, отличающийся тем, что когда хеш-таблица перестраивается, только K/n ключей в среднем должны быть переназначены, где K — число ключей, n число слотов.
В нашем случае слот — это сервер и написанное выше значит, что когда мы убираем/добавляем сервер, мы теряем только примерно K/n записей.

Каким образом это достигается? Тут используется алгоритм кольцевого хэширования.
Клиент считает crc32 от ключа, на выходе получается число. Берем остаток от деления этого числа на количество серверов и получаем номер сервера, на который идти за записью.
(нарисовать на доске, как это работает при изменении количества серверов).
